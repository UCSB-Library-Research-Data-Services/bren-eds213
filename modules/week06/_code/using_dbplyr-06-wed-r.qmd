---
title: "dbplyr"
---



```{r}
library(tidyverse)
library(DBI)         # low-level database interface, comparable to what we saw in Python
library(dbplyr)
library(duckdb)
```


## Connecting to a database

This says: I want to use SQLite, here's the filename.
If using remote database, would use appropriate driver (likely MySQL or PostgreSQL driver)
and would supple "connection string" that gives hostname, user account,
database name, etc.

```{r}
conn <- DBI::dbConnect(RSQLite::SQLite(), "database.db")
```

All the magic is right here.  A dataframe view of a database table.

```{r}
species <- tbl(conn, "Species")
```


## At this point, can use the same fucntions like for any data frame


```{r}
species %>%
  filter(Relevance=="Study species") %>%
  select(Scientific_name) %>%
  arrange(Scientific_name) %>%
  head(3)
```

### Add show_query() to the end to see what SQL it is sending!

```{r}
species %>%
  filter(Relevance=="Study species") %>%
  select(Scientific_name) %>%
  arrange(Scientific_name) %>%
  head(3) %>% show_query()
```

**Great way to learn SQL!!**

### These "tables" are not true dataframes

```{r}
str(species)  # weirdo structure, gibberish to me
dim(species)  # unknown row dimension
```

What `dbplyr` is doing behind the scenes is translating
all those dplyr operations into SQL, sending the
SQL to the database, retrieving results, etc.

```{r}
# Want a local copy that is a true dataframe?  Add collect():
local_copy <- species %>% collect()
str(local_copy)
dim(local_copy)
```

However you can do pretty much anything with these quasi-tables,
including grouping, summarization, joins, etc.

```{r}
species %>%
  group_by(Relevance) %>%
  summarize(num_species = n()) %>% show_query()

# Even mutating columns gets translated into SQL operations, wild!
species %>%
  mutate(Code = paste("X", Code)) %>% show_query()
```


**Limitation**: no way to add or update data.  dbplyr is view only.
If you want to add or update data, you'll need to use
DBI functions.

